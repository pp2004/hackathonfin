Technical Plan for an AI-Powered Investor Profile Solution
Overview and Objectives
We propose a web application that leverages UBS’s investor profile data and advanced AI services to deliver personalized insights and recommendations. The goal is to enhance the advisory experience by combining client-specific data (risk profile, portfolio holdings, transaction history) with CIO research content and AI analytics. This aligns with UBS’s Circle One vision of delivering “new daily content based on the latest CIO House Views” in a digestible, personalized way
ubs.com
ubs.com
. The application will allow advisors (or clients) to view a dashboard for each investor with key profile metrics, portfolio analytics, and AI-generated market insights tailored to their interests and risk appetite.
Data and Tools at Our Disposal
Investor Profile Data: We have a dataset of 47 anonymized client personas, each with detailed investor profile (IP) information across multiple points in time. The IP data includes the client’s risk tolerance, investment horizon, and product knowledge/experience across various financial instruments (e.g. funds, derivatives, structured products)【28†】. This information is critical for providing suitable advice that matches the client’s objectives and “reflects [their] true risk appetite”. We also know each client’s mandate type (Advisory vs. Discretionary) and whether their IP status is complete or not (an incomplete profile would restrict trading). Historical snapshots of the IP (e.g. dated 2023, 2024, 2025) show how the client’s preferences have changed over time【28†】, giving insight into whether they have become more conservative or aggressive, i.e. “reactive” vs. “established” in their behavior. Portfolio and Transaction Data: For each client persona, we have their current portfolio holdings (positions) with market values, asset classes, and the portfolio’s volatility. We also have a benchmark Strategic Asset Allocation (SAA) volatility for the client’s risk level. This lets us determine if the portfolio’s risk is within the tolerated range or breaching it. (UBS’s portfolio approach “monitor[s] the risk level of your portfolio against your selected risk tolerance,” which is “derived from our Strategic Asset Allocation.”) A flag in the data Portfolio Risk Breach will be True if the actual volatility exceeds the SAA target for that risk profile. Additionally, we have each portfolio’s YTD performance (which can be compared to a relevant benchmark) and the number of positions held. The transaction history dataset (318 trades) includes details like trade date, buy/sell, instrument, amount, whether the trade was advisor-assisted or self-directed, and the product category of each trade. This can be used to gauge client activity, behavior (e.g. frequent trader or long-term holder), and whether they’re investing in line with their profile knowledge. For example, if a client with low experience in derivatives suddenly trades options, that’s noteworthy. These data tables will be stored in a relational database with tables for clients, positions, and transactions. For instance, a clients table holds each client’s profile info (persona type, risk tolerance, base currency, current volatility, etc.), and a portfolio_positions table stores each holding with its value, asset class, and weight in the portfolio. Internal AI Tools: We have access to UBS’s internal AI bots – specifically ChatGPT and ResearchGPT – via APIs. The ResearchGPT bot is designed to analyze CIO Office publications. We have a working integration example that uses the Zulip chat API to query the bot. By sending a prompt containing, for example, “summaries from the last 24h CIO publications” and asking for an assessment of user interest, the bot returns a structured answer with each topic’s score (0–100) and justification. The provided code snippet demonstrates how to call this API (using an API endpoint and API key) and poll for the bot’s reply. For our product, this means we can programmatically fetch the latest market insights curated by the CIO, along with an AI-generated summary and a relevance score indicating how interesting or important that insight might be to clients in general. We will leverage this to populate a “Market Insights” section in the app. In addition to ResearchGPT, we can use general ChatGPT (via Azure OpenAI services) for other advanced features – for instance, answering ad-hoc questions or providing explanatory text based on a client’s data. We also have the full suite of Azure cognitive services available (language translation, sentiment analysis, etc.), which could be integrated if needed (for example, translating insights for non-English-speaking clients or analyzing sentiment of news).
Key Features and User Flows
Using the above data and tools, the final product will deliver several core features:
1. Client Overview Dashboard: A dashboard view for each client persona, combining their investor profile and current portfolio status. At a glance, the advisor sees the client’s Risk Level vs. Portfolio Risk (e.g. a gauge or indicator if the portfolio volatility is above what’s allowed for their risk tolerance), the Portfolio Composition (perhaps a pie chart of asset classes or major holdings), and key profile info such as mandate type and investment horizon. Any important flags are highlighted – for example, if the Portfolio Risk Breach is true, the dashboard might show a warning that “This portfolio’s risk exceeds the client’s selected tolerance!” along with the actual vs. recommended volatility. This directly addresses the need to ensure investments remain suitable for the client’s risk appetite (a principle outlined in UBS’s approach to monitor portfolios against risk tolerance). Another highlight could be the Last IP Review Date – if the profile hasn’t been updated in a long time or is incomplete, prompt the advisor to review it (since an incomplete IP means the client cannot trade).
2. Investor Profile Details: A section or modal that shows detailed KYC/IP information about the client. This includes their Investment Objectives, Risk Tolerance level (e.g. cautious, balanced, dynamic), Investment Horizon (short, medium, long term), and a breakdown of their Knowledge & Experience by product category. We will present the product categories (FX, Funds, ETFs, Alternatives, Structured products, etc.) with indicators if the client is experienced or knowledgeable in each. (These correspond to the columns in the IP data; e.g. whether they have traded >10 times or have relevant background in each category.) This is important for context – as stated in the IP form, understanding a client’s experience “helps us to provide [them] with the appropriate explanation of product features and risks.” In practical terms, an advisor using the app can quickly see, for example, that Client A is knowledgeable in *Equity-Linked Notes and ETFs but not in Hedge Funds, and tailor any discussion or product pitch accordingly. The profile section can also show historical changes: e.g., “Client increased risk tolerance from ‘Balanced’ to ‘Dynamic’ on 5/5/2025” or “Client’s investment horizon changed from Long (10+ years) to Medium (5-10 years) last year”. This gives insight into whether the client has become more risk-seeking or cautious over time. We have the timestamps (IP snapshots) to derive such insights.
3. Market Insights & CIO Content Recommendations: A Market Insights panel will display the latest insights from the CIO research that are most relevant to the client. We will utilize the ResearchGPT bot to fetch summaries of the latest publications (for example, daily or weekly CIO House View pieces). The bot’s response will be parsed into individual insight cards, each with a title, a brief summary, and an “interest score.” For instance, the bot might return something like “AI Chip Export Restrictions & Tech Sector Outlook – Score: 95/100 (Highly relevant due to the intersection of AI and geopolitics affecting tech investments)…【JSON】”. We would show “AI Chip Export Restrictions & Tech Sector Outlook (Score 95)” and the summary/blurb from the bot’s reply. The score can be used as a relevance indicator (perhaps color-coded: high scores in green indicating very compelling content). Advisors can use this to decide which research insights to share with the client. Moreover, we can cross-match the content topics with the client’s profile/interests. For example, if a client has a lot of tech stocks or has expressed interest in technology sector, an insight about AI chips export restrictions is clearly pertinent. We can enhance the relevance by simple keyword matching between the insight and the client’s portfolio (e.g. if the insight is about Federal Reserve policy and the client holds mostly bonds, that’s relevant). In the hackathon timeframe, a simpler approach is to just display the top ~3 insights by score to all users, assuming those are broadly interesting. This feature brings dynamic, up-to-date content into the app, echoing Circle One’s promise of “relevant, personalized, on-time” insights at clients’ fingertips
ubs.com
.
4. Personalized Recommendations/Alerts: Going a step further, the app can generate a few actionable recommendations for the advisor based on the data. For example:
If a client’s portfolio risk is too high, recommend “Consider rebalancing by reducing equity exposure to bring portfolio in line with risk profile.”
If the client has excess cash or certain asset allocation gaps relative to CIO model, the app could highlight “Client’s allocation to Alternatives is 0%, while peers in this risk category typically hold 5%. Consider discussing alternative investments (the client is experienced in Private Equity).”
If the client’s IP was recently updated to reflect a shorter horizon, perhaps recommend more liquid or lower-volatility products.
These suggestions can be generated using rules or even by feeding the client’s situation to an AI model. Since “advanced AI features and all Azure services” are available, we might use Azure OpenAI GPT-4 to generate advice given a structured prompt with the client’s profile and portfolio summary. However, due to compliance, we likely stick to rule-based or pre-approved logic for actual product recommendations. At minimum, the system will flag discrepancies (risk breaches, allocation vs. SAA) and present them clearly. Advisors can then consult the CIO insights (from feature 3) or ask further questions to the AI for guidance.
5. Interactive Q&A (Stretch Goal): As an advanced feature, we can integrate a chat interface where the advisor can ask natural language questions about the client or market. For example, “What changed in the client’s profile since last year?” or “How did their portfolio perform vs. the CIO model portfolio?” or even “What investment opportunities might interest this client now?” The backend can handle these queries by either:
Using a predefined set of Q&A (e.g., we detect certain question types and respond with templated analysis using the data we have), or
Using an Azure OpenAI model (ChatGPT) to dynamically answer. The latter would involve crafting a prompt with relevant data (client profile facts + maybe recent insights) and the question, then letting the model output a answer. For instance, “Client X has risk tolerance D, portfolio 60% equities 40% bonds, etc… Given they are knowledgeable in ETFs, suggest what content or strategy to discuss with them.” The model could output something like a personalized narrative. This is ambitious but showcases cutting-edge use of AI for personalized advice. Any such output can be reviewed or tuned for compliance.
Given hackathon time constraints, this is a stretch goal – we will focus on the core dashboard and insights first. But the architecture will be ready to plug in such a chat feature (leveraging the existing ChatGPT integration in our environment).
System Architecture
The solution follows a client-server architecture with a modern web tech stack:
Backend: A Node.js server (using Express or similar) with TypeScript, as indicated by the project setup. We use a PostgreSQL database (or SQLite for prototyping) to store the data. The database is defined via Drizzle ORM, with tables such as clients, portfolio_positions, transactions, and market_insights. The schema definitions show how data is structured, for example each client entry stores persona type, riskTolerance, portfolioValue, volatility, etc., and each position entry stores instrument name, asset class, value, and weight. The server exposes a RESTful API to the frontend. Key endpoints likely include:
GET /api/clients – list all client personas (basic info like name, persona category, risk level, etc., to populate a selection menu).
GET /api/clients/{id} – detailed profile for one client, including current IP data, portfolio breakdown, recent performance, etc.
GET /api/clients/{id}/positions – list of holdings (or this could be embedded in the client detail).
GET /api/clients/{id}/transactions – (if needed, for drilling into history).
GET /api/insights – latest market insights (fetched from CIO ResearchGPT). This could return a list of insight objects with title, summary, score, and perhaps a link to full report.
POST /api/insights/refresh – (admin or internal) trigger the backend to call the ResearchGPT bot for new data. This endpoint would execute the logic similar to the provided Python snippet: send the request to Zulip, poll for the reply, parse it, and update the market_insights table with new entries.
The ResearchGPT integration will be encapsulated in the backend. Using the config provided, we will call the Zulip API from Node (we can use axios or node-fetch to do an HTTPS POST). It will POST a private message to the ubs-research-gpt-bot with the content asking for the summary of CIO publications. After sending, the backend will poll the endpoint for new messages (the same logic as the Python example, just implemented in Node). This ensures we don’t return until we get the bot’s answer. We may implement this in a slightly asynchronous way – for example, the refresh endpoint could immediately respond with “refresh started” and a WebSocket or long-poll could deliver results when ready. But given a 50-second worst-case wait, it might also be acceptable in a synchronous call during development. Once the response is received (in HTML/markdown format), we parse it. Each <h3> heading likely denotes a new insight topic. We extract the title (text of the <h3>), the score from the following <strong>Score: X/100 text, and the justification/summary content (the paragraphs that follow). This parsed data is then stored into the market_insights table with fields for title, summary, score, etc. (There is also a recommendations JSON field – we can use this to store any structured data like a list of which personas or asset classes the insight is relevant to, if we derive that). Storing the insights in the DB allows us to serve them quickly to many front-end users and also keeps a history of insights. We will cite the source or date for each insight as well, so users know it’s from CIO (e.g. “CIO Market Update – Jul 7, 2025”). In addition to this, the backend can also incorporate Azure OpenAI calls if we do the Q&A feature. That would involve calling Azure’s REST API for OpenAI with the prepared prompt and returning the answer to the frontend. Security & Config: All sensitive keys (the Zulip API key, any Azure API keys) will be stored server-side (as environment variables or config files) and not exposed to the frontend. The backend will authenticate to these services internally. We might include basic auth or JWT for the frontend to login (there is a users table in the schema for app login), but for hackathon purposes, we might skip heavy auth and use a simple login form or dummy user. The app is intended for internal use by advisors, so it would reside behind UBS’s firewall or authentication anyway in production.
Frontend: A single-page application (SPA) built with React (likely TypeScript React, given the use of Vite and hookform libraries). The UI will be designed in line with UBS branding (perhaps inspired by the Circle One microsite styles). We will have a main screen where an advisor can select a client persona to view (e.g. a dropdown or list of client names/personas). Once selected, the dashboard (feature 1) is shown. The layout might have panels or tabs for “Profile”, “Portfolio”, “Insights”, etc., or a single scrolling page with sections:
Profile Card: showing key profile info (risk level, horizon, mandate, last review date, etc.) in a concise format.
Portfolio Summary: could include a pie chart of asset allocation. We can compute allocation by asset class from the positions data. For visualization, we can use a chart library (like Chart.js or Recharts) to render this. Also show total portfolio value and YTD performance (the portfolioValue and ytdPerformance fields).
Risk Indicator: a component showing current volatility vs target. For example, a small gauge or simply text like “Volatility: 9.8% (Target: 9.5%)”. If breach, this could be highlighted in red.
Insights Carousel/List: display the fetched CIO insights as cards. Each card will have the insight title and maybe the first 1-2 sentences of the summary. The advisor can click to expand or view more details. Because the bot’s reply is in HTML (with formatting like bullet points or numbered list in the 400-word summary), we can either render that HTML directly in a modal or detail view, or clean it to plain text. Since the bot reply is well-formatted (it even used <p> and <strong> tags as we saw), we can safely present it as rich text. Each insight card might also have a tag or icon to indicate its score (e.g. a score of 95 could show as “★ ★ ★ ★ ★” if we want a visual, or just the number).
Historical IP changes (optional): if useful, a small timeline or list indicating changes in risk tolerance or big shifts. E.g. “Jan 2023: Risk tolerance = Balanced; Nov 2024: Risk = Dynamic” etc.
Transactions (optional): possibly a recent transactions list or interesting stats (like % of trades that were unsolicited vs advised, or turnover rate). This might be nice to have but not critical for MVP. It could, however, feed into the “Knowledge/Experience” – e.g. highlight that “client executed 5 derivative trades in last year (Experienced in derivatives).”
The frontend will call the backend APIs to fetch all this data. We will use asynchronous calls (via fetch or Axios) to populate the state. For state management, simple React hooks or context can suffice given the app scope. Form handling (we saw react-hook-form in dependencies) might be used if there’s any input forms – maybe for a login or for an advisor to add notes. But primarily, this is a read-only dashboard app in this context. We will also include UI for triggering the AI features if needed. For example, a “Refresh Insights” button that calls the refresh endpoint (or it might automatically refresh every morning). If we implement the Q&A chat, a chat widget would be present where the advisor types a question and the answer is shown (this can be done by calling an /ask endpoint on backend which relays to Azure OpenAI). Visual Design: We aim for a clean, modern interface that could eventually be embedded in UBS’s advisor portal or as part of Circle One. We will ensure it’s responsive (perhaps not a primary concern for hack demo, but good to note). Key info will be presented with clarity – using charts, icons, and tooltips to explain terms (like what is SAA Volatility, etc.). The design will follow the logical grouping from headings to bullet points as per the user’s readability guidelines, ensuring information is easily scannable.
Integration of Azure Services
Beyond the internally hosted ResearchGPT (which presumably itself might be powered by Azure OpenAI under the hood), we have the opportunity to use Azure’s AI services in various ways:
Azure OpenAI (GPT-4/GPT-3.5): for any custom prompts outside the provided bot’s scope. For instance, generating the personalized recommendations or answering follow-up questions as described. This would involve constructing system and user prompts with our data. We must ensure not to send any sensitive client data to external services unless permitted – since this is internal hackathon and Azure can be considered within our cloud, it might be acceptable with proper data handling. We can also use Azure OpenAI to summarize long texts (if needed to distill a lengthy CIO report beyond the summary provided).
Azure Cognitive Search + QnA: We could index the CIO reports or even the investor profile knowledge base (regulations, definitions from the IP form) and allow semantic search or Q&A. For example, if an advisor asks “What is a Knock-Out ELN?” the app could retrieve the definition from the IP form glossary (which lists product definitions in the questionnaire). This would enrich the advisor’s toolset with on-demand definitions or educational content.
Azure Translation: If we needed to show content in the client’s preferred language, we could translate the AI summaries or UI text on the fly.
Azure Forms/OCR: We already have the IP form template (PDF) – not needed for this app, but if we wanted to digitize the completion of a new IP form, Azure Form Recognizer could help parse a filled form. However, this is out of scope for now, since we already have digital data.
Azure Analytics (PowerBI, etc.): We could connect the data to PowerBI for deeper analysis, but within our custom app we’ll implement charts directly. For future, integrating with a BI tool could allow advisors to do more exploratory analysis on client segments (e.g. comparing all “Reactive” clients).
Backend Implementation Details
The backend is implemented in TypeScript. We will use the Drizzle ORM to manage database interactions. The drizzle.config.ts and schema definitions are already prepared, so we can quickly generate the database schema in our environment (running drizzle-kit push as per package scripts). Next, we’ll write a data importer to load the provided Excel data into the database. Likely, we’ll write a one-time Node script or use a Jupyter notebook to read Hackathon_Data_without_CID.xlsx (as we have done in analysis) and insert records. Each persona in the “Persona Portfolios” sheet will become a row in clients table (with fields like name/persona category, risk tolerance code, base currency, currentVolatility, saaVolatility, positionsCount, etc.). Then for each client, we load their positions from the “Positions” sheet – summing or identifying current value and computing weights. If weights are not given, we can calculate weight = position value / total portfolio value. We’ll also categorize each position by asset class using the “Instrument Details” sheet (matching by ISIN or Valor to get asset class info). This populates portfolio_positions. Transactions from the “Transactions” sheet will be filtered by client ID and inserted into transactions table with relevant fields (date, action, instrument name, amount, type). We will likely not store all 45 columns, only key ones like action, date, amount, product category (for reference of what kind of trade it was), etc., to keep it concise. With data in place, we implement the API controllers. Using Express, we define routes and use Drizzle to query the DB. For example, in /api/clients/:id, we can join the client info with their positions and maybe a computed breakdown. Or we simply send separate requests from frontend (one for client info, one for positions list). The market_insights table will be filled either by a scheduled job (could use a cron or simply manual trigger as needed). For the Zulip API integration, since the hack environment may not allow direct outbound calls without proxy, we must ensure we handle SSL correctly (the example disabled SSL verification for simplicity). In Node, we can use process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0' if needed or properly handle certificates. We’ll keep the Zulip credentials (email, API key, bot email) in a config file or environment. The logic will mirror the Python snippet:
js
Copy
Edit
// Pseudo-code in Node
const resp = await fetch(`${ZULIP_URL}/messages`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
  body: new URLSearchParams({
    type: 'private',
    to: RECIPIENT_EMAIL,
    content: promptText 
  }),
  // basic auth with EMAIL:API_KEY
});
const result = await resp.json();
if (result.result !== 'success') throw Error("Zulip API error");
const sentMsgId = result.id;
// Poll for response
for (let attempt=0; attempt<10; attempt++) {
   await new Promise(r => setTimeout(r, 5000));
   const msgsResp = await fetch(`${ZULIP_URL}/messages?anchor=${sentMsgId}&...&narrow=[{"operator":"pm_with","operand":RECIPIENT_EMAIL}]`, { headers: auth });
   const msgs = (await msgsResp.json()).messages;
   const replies = msgs.filter(m => m.id > sentMsgId && m.sender_email !== EMAIL);
   if (replies.length > 0) {
       const reply = replies[0].content; 
       // parse HTML in reply...
       break;
   }
}
This will yield the HTML content. We then use a DOM parser or regex to extract the relevant pieces. After storing to DB, the new insights are immediately available via GET /api/insights. We should also store a timestamp (lastUpdated) to know when it was last refreshed. One consideration: The ResearchGPT bot is likely returning content in HTML format (with <p>, <h3> etc.). Our backend could convert that to Markdown or keep HTML. Since our front-end can safely render it, we might just send it as is. Alternatively, we convert to a JSON structure: e.g. [ { title: "AI Chip Export...", score:95, summary:"..."} ]. The current plan is to parse and structure it ourselves for ease of use. Additionally, if we incorporate the Q&A chat, the backend would have an /api/ask endpoint. This would take a question and clientId, then compose a prompt for Azure OpenAI. For example, the prompt could be:
pgsql
Copy
Edit
System: You are an expert wealth assistant with access to client profile and market info. Answer succinctly.
User: Here is the client profile: [risk tolerance, knowledge, portfolio summary]. Question: [user’s question].
We’d call the OpenAI API and stream back the answer. This requires careful prompt design and is optional due to time.
Frontend Implementation Details
On the frontend side, after the initial client selection view, the main dashboard will be implemented as a set of React components:
<ClientDashboard> – a container that fetches all needed data for a client and renders sub-components.
<ProfileSummaryCard> – displays the personal/profile info. Could show a few labeled values (perhaps in a table or list format): Risk Tolerance, Mandate Type, Investment Horizon, Last Profile Review, etc. If needed, uses icons or colored badges (e.g. a shield icon with “Dynamic” for risk tolerance).
<PortfolioChart> – renders the pie chart of asset allocation. We’ll derive asset class grouping from positions (e.g. sum all Equities, Bonds, Cash, Alternatives, etc.). Each segment gets a color (the dataset includes a color field per position in schema for chart use).
<RiskIndicator> – shows current vs SAA volatility, possibly a progress bar or simply text. We might also show the numeric risk tolerance (sometimes UBS assigns risk levels numeric or letter codes; in persona data it was “D” which might stand for “Dynamic” risk level).
<InsightsList> – iterates over the insights fetched from /api/insights. Each item rendered by an <InsightCard> component.
<InsightCard> – shows the title, score, and a short snippet. On click, it could open an overlay with the full summary (formatted nicely). We ensure to cite that these summaries are from CIO publications (the content itself might mention the CIO publication implicitly by context; we could add a link “Read full report” if we had the publication URL, but that’s beyond our data – maybe the bot summary alone suffices for now).
If implementing chat: <ChatWidget> – an overlay with a text input and a conversation log, calling the ask API and displaying responses. This can be toggled by the user for interactive Q&A.
We’ll pay attention to the UX/UI to make the app intuitive. For example, if a risk breach exists, clicking the alert might scroll to the portfolio section or show which holding is causing high risk (maybe the one with very high weight in equities). We can also allow sorting or filtering in tables (like sorting positions by value or filtering transactions by year). Form-wise, if we allow editing anything (maybe not in this prototype), we’d use react-hook-form. But primarily, our app is presenting analysis, not collecting input. The frontend styling can use a CSS framework (maybe Tailwind or Bootstrap) or custom CSS with a UBS style guide if available. Given hackathon time, we may use simple Bootstrap for layout and focus on functionality.
Ensuring Compliance and Extensibility
Throughout the implementation, we must ensure the solution respects compliance:
We are using internal data; no client-identifying info is used (IDs are masked).
AI usage (ResearchGPT/ChatGPT) is kept to providing insights and summaries, not making unapproved investment recommendations. We’ll treat the AI suggestions as informational for the advisor, who will make the actual decision. Any recommendation we generate will be based on CIO’s existing guidance or straightforward portfolio math, avoiding unauthorized advice.
The architecture is modular: new data points (e.g. if we later include financial planning info) or new AI capabilities can be added. The database can be extended with more tables or fields (Drizzle makes migrations manageable), and the frontend is component-based for easy expansion.
Finally, this technical implementation can be deployed in UBS’s Azure cloud. The backend could run as a Node service (containerized or App Service), the database on Azure Postgres, and the frontend as a static site or within UBS’s internal web. All Azure cognitive services are available to plug in as needed, making this solution cloud-ready and scalable.
Conclusion
In summary, we will build a comprehensive hackathon solution that integrates client profile analytics with AI-driven content recommendations. Technically, we combine data engineering (ingesting and relating portfolio & profile data) with AI integration (via internal bots and Azure services) and a user-friendly web interface. The end product empowers advisors with a 360° view of their client – from financial profile to up-to-date market insights – in one place. By focusing on the technical execution outlined above, we ensure the final product is not only feature-rich and innovative, but also robust and aligned with UBS’s digital strategy of personalized, insight-driven wealth management. Sources:
UBS Investor Profile Questionnaire – Importance of understanding client’s situation and risk appetite
UBS Investor Profile Questionnaire – Monitoring portfolio risk vs. tolerance (SAA-based)
UBS Circle One Media Release – Daily CIO content and personalized insights for clients